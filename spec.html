<!doctype html>
<meta charset="utf8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow.min.css">
<title>Binary AST Tree Grammar</title>
<pre class=metadata>
status: proposal
contributors: Shu-yu Guo, Ecma International
</pre>
<emu-intro id="intro">
  <h1>Binary AST Tree Grammar</h1>
  <p>The Binary AST Tree Grammar is isomorphic to ECMA-262 Syntactic Grammar. That is, an instance of a production of the Binary AST grammar, or a <dfn>Binary AST Node</dfn>, corresponds to some Parse Node in the ECMA-262 syntactic grammar. This document specifies the following things.</p>
  <ol>
    <li>The tree grammar itself described in IDL and its well-formedness.</li>
    <li>The abstract operation Ecmaify(_binaryAST_) from Binary AST Nodes to Parse Nodes by case analysis.</li>
    <li>The abstract operation ParseNodesAreSimilar(_node1_, _node2_) from pairs of Parse Nodes to Boolean.</li>
  </ol>
  <p>A compliant Binary AST Encoder, for a source text that matches either the |Script| or |Module| goal symbol to produce a Parse Node _N_, must produce a Binary AST Node _B_ such that ParseNodesAreSimilar(Ecmaify(_B_), _N_) is *true*.</p>
  <p>The inverse of Ecmaify, Unecmaify, is not specified here. The inverse transform is the encoding of Parse Nodes. For _B_ and _N_ as above, for all _M_ such that ParseNodesAreSimilar(_M_, _N_) is *true*, Unecmaify(_M_) is _B_.</p>
</emu-intro>

<emu-clause id="tree-grammar">
  <h1>Tree Grammar</h1>
  <p>This section is derived from <a href="https://github.com/shapesecurity/shift-spec/blob/es2017/spec.idl">Shift AST Spec</a> and parts are Copyright 2014-2017 Shape Security, Inc.</p>
  <p>Unlike the Shift AST spec, interface types are not used to inherit fields to control over ordering of fields. Type hierarchies that are not used to discriminate are collapsed to make space costs simple. Nor are they used to discriminate types, for which explicitly discriminated unions types are used.</p>
  <emu-note>Whereas Shift AST's design principle is ease of search-and-replace of node types, Binary AST's design principle is ease of verification and ease of associating different behaviors with syntactically different (but possibly lexically similar) productions.</emu-note>
  <p>The grammar is presented in WebIDL with the `[TypeIndicator]` and `NonEmpty` extensions per Shift AST spec. The `typedefs` of `or` types are to be read as recursive sum types.</p>

  <pre><code class="language-webidl">
// Type aliases and enums.

typedef FrozenArray<(SpreadElement or Expression)> Arguments;
typedef DOMString string;
typedef string Identifier;
typedef string IdentifierName;
typedef string Label;

enum VariableDeclarationKind {
  "var",
  "let",
  "const"
};

enum CompoundAssignmentOperator {
  "+=",
  "-=",
  "*=",
  "/=",
  "%=",
  "**=",
  "<<=",
  ">>=",
  ">>>=",
  "|=",
  "^=",
  "&="
};

enum BinaryOperator {
  ",",
  "||",
  "&&",
  "|",
  "^",
  "&",
  "==",
  "!=",
  "===",
  "!==",
  "<",
  "<=",
  ">",
  ">=",
  "in",
  "instanceof",
  "<<",
  ">>",
  ">>>",
  "+",
  "-",
  "*",
  "/",
  "%",
  "**",
};

enum UnaryOperator {
  "+",
  "-",
  "!",
  "~",
  "typeof",
  "void",
  "delete"
};

enum UpdateOperator {
  "++",
  "--"
};


// Binary AST delayed assertions

interface AssertedScope {
  attribute FrozenArray<IdentifierName> varDeclaredNames;
  attribute FrozenArray<IdentifierName> lexicallyDeclaredNames;
  attribute FrozenArray<IdentifierName> capturedNames;
  attribute boolean hasDirectEval;
};


// nodes

interface Node {
  [TypeIndicator] readonly attribute Type type;
};

typedef (Script or Module) Program;

typedef (DoWhileStatement or
         ForInStatement or
         ForOfStatement or
         ForStatement or
         WhileStatement)
        IterationStatement;

typedef (Block or
         BreakStatement or
         ContinueStatement or
         ClassDeclaration or
         DebuggerStatement or
         EmptyStatement or
         ExpressionStatement or
         FunctionDeclaration or
         IfStatement or
         IterationStatement or
         LabelledStatement or
         ReturnStatement or
         SwitchStatement or
         SwitchStatementWithDefault or
         ThrowStatement or
         TryCatchStatement or
         TryFinallyStatement or
         VariableDeclaration or
         WithStatement)
        Statement;

typedef (LiteralBooleanExpression or
         LiteralInfinityExpression or
         LiteralNullExpression or
         LiteralNumericExpression or
         LiteralStringExpression)
        Literal;

typedef (Literal or
         LiteralRegExpExpression or
         ArrayExpression or
         ArrowExpression or
         AssignmentExpression or
         BinaryExpression or
         CallExpression or
         CompoundAssignmentExpression or
         ComputedMemberExpression or
         ConditionalExpression or
         ClassExpression or
         FunctionExpression or
         IdentifierExpression or
         NewExpression or
         NewTargetExpression or
         ObjectExpression or
         UnaryExpression or
         StaticMemberExpression or
         TemplateExpression or
         ThisExpression or
         UpdateExpression or
         YieldExpression or
         YieldStarExpression or
         AwaitExpression)
        Expression;

typedef (ComputedPropertyName or
         LiteralPropertyName)
        PropertyName;

typedef (Method or Getter or Setter) MethodDefinition;

typedef (MethodDefinition or
         DataProperty or
         ShorthandProperty)
        ObjectProperty;

typedef (ExportAllFrom or
         ExportFrom or
         ExportLocals or
         ExportDefault or
         Export)
        ExportDeclaration;

typedef (ImportNamespace or Import) ImportDeclaration;


// bindings

interface BindingIdentifier : Node {
  attribute Identifier name;
};

typedef (ObjectBinding or
         ArrayBinding)
        BindingPattern;
typedef (BindingPattern or
         BindingIdentifier)
        Binding;

typedef (AssignmentTargetIdentifier or
         ComputedMemberAssignmentTarget or
         StaticMemberAssignmentTarget)
        SimpleAssignmentTarget;
typedef (ObjectAssignmentTarget or
         ArrayAssignmentTarget)
        AssignmentTargetPattern;
// `DestructuringAssignmentTarget`
typedef (AssignmentTargetPattern or
         SimpleAssignmentTarget)
        AssignmentTarget;

// `FormalParameter`
typedef (Binding or
         BindingWithDefault)
        Parameter;

interface BindingWithDefault : Node {
  attribute Binding binding;
  attribute Expression init;
};

interface AssignmentTargetIdentifier : Node {
  attribute Identifier name;
};

interface ComputedMemberAssignmentTarget : Node {
  // The object whose property is being assigned.
  attribute (Expression or Super) _object;
  // The expression resolving to the name of the property to be accessed.
  attribute Expression expression;
};

interface StaticMemberAssignmentTarget : Node {
  // The object whose property is being assigned.
  attribute (Expression or Super) _object;
  // The name of the property to be accessed.
  attribute IdentifierName property;
};

// `ArrayBindingPattern`
interface ArrayBinding : Node {
  // The elements of the array pattern; a null value represents an elision.
  attribute FrozenArray<(Binding or BindingWithDefault)?> elements;
  attribute Binding? rest;
};

// `SingleNameBinding`
interface BindingPropertyIdentifier : Node {
  attribute BindingIdentifier binding;
  attribute Expression? init;
};

// `BindingProperty :: PropertyName : BindingElement`
interface BindingPropertyProperty : Node {
  attribute PropertyName name;
  attribute (Binding or BindingWithDefault) binding;
};

typedef (BindingPropertyIdentifier or
         BindingPropertyProperty)
        BindingProperty;

interface ObjectBinding : Node {
  attribute FrozenArray<BindingProperty> properties;
};

// This interface represents the case where the initializer is present in
// `AssignmentElement :: DestructuringAssignmentTarget Initializer_opt`.
interface AssignmentTargetWithDefault : Node {
  attribute AssignmentTarget binding;
  attribute Expression init;
};

// `ArrayAssignmentPattern`
interface ArrayAssignmentTarget : Node {
  // The elements of the array pattern; a null value represents an elision.
  attribute FrozenArray<(AssignmentTarget or AssignmentTargetWithDefault?)> elements;
  attribute AssignmentTarget? rest;
};

// `AssignmentProperty :: IdentifierReference Initializer_opt`
interface AssignmentTargetPropertyIdentifier : Node {
  attribute AssignmentTargetIdentifier binding;
  attribute Expression? init;
};

// `AssignmentProperty :: PropertyName : Node`
interface AssignmentTargetPropertyProperty : Node {
  attribute PropertyName name;
  attribute (AssignmentTarget or AssignmentTargetWithDefault) binding;
};

typedef (AssignmentTargetPropertyIdentifier or
         AssignmentTargetPropertyProperty)
        AssignmentTargetProperty;

// `ObjectAssignmentPattern`
interface ObjectAssignmentTarget : Node {
  attribute FrozenArray<AssignmentTargetProperty> properties;
};


// classes

interface ClassExpression : Node {
  attribute BindingIdentifier? name;
  attribute Expression? super;
  attribute FrozenArray<ClassElement> elements;
};

interface ClassDeclaration : Node {
  attribute BindingIdentifier name;
  attribute Expression? super;
  attribute FrozenArray<ClassElement> elements;
};

interface ClassElement : Node {
  // True iff `IsStatic` of ClassElement is true.
  attribute boolean isStatic;
  attribute MethodDefinition method;
};


// modules

interface Module : Node {
  attribute FrozenArray<Directive> directives;
  attribute FrozenArray<(ImportDeclaration or ExportDeclaration or Statement)> items;
};

// An `ImportDeclaration` not including a namespace import.
interface Import : Node {
  attribute string moduleSpecifier;
  // `ImportedDefaultBinding`, if present.
  attribute BindingIdentifier? defaultBinding;
  attribute FrozenArray<ImportSpecifier> namedImports;
};

// An `ImportDeclaration` including a namespace import.
interface ImportNamespace : Node {
  attribute string moduleSpecifier;
  // `ImportedDefaultBinding`, if present.
  attribute BindingIdentifier? defaultBinding;
  attribute BindingIdentifier namespaceBinding;
};

interface ImportSpecifier : Node {
  // The `IdentifierName` in the production `ImportSpecifier :: IdentifierName as ImportedBinding`;
  // absent if this specifier represents the production `ImportSpecifier :: ImportedBinding`.
  attribute IdentifierName? name;
  attribute BindingIdentifier binding;
};

// `export * FromClause;`
interface ExportAllFrom : Node {
  attribute string moduleSpecifier;
};

// `export ExportClause FromClause;`
interface ExportFrom : Node {
  attribute FrozenArray<ExportFromSpecifier> namedExports;
  attribute string moduleSpecifier;
};

// `export ExportClause;`
interface ExportLocals : Node {
  attribute FrozenArray<ExportLocalSpecifier> namedExports;
};

// `export VariableStatement`, `export Declaration`
interface Export : Node {
  attribute (FunctionDeclaration or ClassDeclaration or VariableDeclaration) declaration;
};

// `export default HoistableDeclaration`,
// `export default ClassDeclaration`,
// `export default AssignmentExpression`
interface ExportDefault : Node {
  attribute (FunctionDeclaration or ClassDeclaration or Expression) body;
};

// `ExportSpecifier`, as part of an `ExportFrom`.
interface ExportFromSpecifier : Node {
  // The only `IdentifierName in `ExportSpecifier :: IdentifierName`,
  // or the first in `ExportSpecifier :: IdentifierName as IdentifierName`.
  attribute IdentifierName name;
  // The second `IdentifierName` in `ExportSpecifier :: IdentifierName as IdentifierName`,
  // if that is the production represented.
  attribute IdentifierName? exportedName;
};

// `ExportSpecifier`, as part of an `ExportLocals`.
interface ExportLocalSpecifier : Node {
  // The only `IdentifierName in `ExportSpecifier :: IdentifierName`,
  // or the first in `ExportSpecifier :: IdentifierName as IdentifierName`.
  attribute IdentifierExpression name;
  // The second `IdentifierName` in `ExportSpecifier :: IdentifierName as IdentifierName`, if present.
  attribute IdentifierName? exportedName;
};


// property definition

// `MethodDefinition :: PropertyName ( UniqueFormalParameters ) { FunctionBody }`,
// `GeneratorMethod :: * PropertyName ( UniqueFormalParameters ) { GeneratorBody }`,
// `AsyncMethod :: async PropertyName ( UniqueFormalParameters ) { AsyncFunctionBody }`
interface Method : Node {
  // True for `AsyncMethod`, false otherwise.
  attribute boolean isAsync;
  // True for `GeneratorMethod`, false otherwise.
  attribute boolean isGenerator;
  // The `UniqueFormalParameters`.
  attribute PropertyName name;
  attribute FormalParameters params;
  attribute FunctionBody body;
};

// `get PropertyName ( ) { FunctionBody }`
interface Getter : Node {
  attribute PropertyName name;
  attribute FunctionBody body;
};

// `set PropertyName ( PropertySetParameterList ) { FunctionBody }`
interface Setter : Node {
  attribute PropertyName name;
  // The `PropertySetParameterList`.
  attribute Parameter param;
  attribute FunctionBody body;
};

// `PropertyDefinition :: PropertyName : AssignmentExpression`
interface DataProperty : Node {
  attribute PropertyName name;
  // The `AssignmentExpression`.
  attribute Expression expression;
};

// `PropertyDefinition :: IdentifierReference`
interface ShorthandProperty : Node {
  // The `IdentifierReference`.
  attribute IdentifierExpression name;
};

interface ComputedPropertyName : Node {
  attribute Expression expression;
};

// `LiteralPropertyName`
interface LiteralPropertyName : Node {
  attribute string value;
};


// literals

// `BooleanLiteral`
interface LiteralBooleanExpression : Node {
  attribute boolean value;
};

// A `NumericLiteral` for which the Number value of its MV is positive infinity.
interface LiteralInfinityExpression : Node { };

// `NullLiteral`
interface LiteralNullExpression : Node { };

// `NumericLiteral`
interface LiteralNumericExpression : Node {
  attribute double value;
};

// `RegularExpressionLiteral`
interface LiteralRegExpExpression : Node {
  attribute string pattern;
  attribute string flags;
};

// `StringLiteral`
interface LiteralStringExpression : Node {
  attribute string value;
};


// other expressions

// `ArrayLiteral`
interface ArrayExpression : Node {
  // The elements of the array literal; a null value represents an elision.
  attribute FrozenArray<(SpreadElement or Expression)?> elements;
};

// `ArrowFunction`,
// `AsyncArrowFunction`
interface ArrowExpression : Node {
  // True for `AsyncArrowFunction`, false otherwise.
  attribute boolean isAsync;
  attribute FormalParameters params;
  attribute (FunctionBody or Expression) body;
};

// `AssignmentExpression :: LeftHandSideExpression = AssignmentExpression`
interface AssignmentExpression : Node {
  // The `LeftHandSideExpression`.
  attribute AssignmentTarget binding;
  // The `AssignmentExpression` following the `=`.
  attribute Expression expression;
};

// `ExponentiationExpression`,
// `MultiplicativeExpression`,
// `AdditiveExpression`,
// `ShiftExpression`,
// `RelationalExpression`,
// `EqualityExpression`,
// `BitwiseANDExpression`,
// `BitwiseXORExpression`,
// `BitwiseORExpression`,
// `LogicalANDExpression`,
// `LogicalORExpression`
interface BinaryExpression : Node {
  attribute BinaryOperator operator;
  // The expression before the operator.
  attribute Expression left;
  // The expression after the operator.
  attribute Expression right;
};

interface CallExpression : Node {
  attribute (Expression or Super) callee;
  attribute Arguments arguments;
};

// `AssignmentExpression :: LeftHandSideExpression AssignmentOperator AssignmentExpression`
interface CompoundAssignmentExpression : Node {
  attribute CompoundAssignmentOperator operator;
  // The `LeftHandSideExpression`.
  attribute SimpleAssignmentTarget binding;
  // The `AssignmentExpression`.
  attribute Expression expression;
};

interface ComputedMemberExpression : Node {
  // The object whose property is being accessed.
  attribute (Expression or Super) _object;
  // The expression resolving to the name of the property to be accessed.
  attribute Expression expression;
};

// `ConditionalExpression :: LogicalORExpression ? AssignmentExpression : AssignmentExpression`
interface ConditionalExpression : Node {
  // The `LogicalORExpression`.
  attribute Expression test;
  // The first `AssignmentExpression`.
  attribute Expression consequent;
  // The second `AssignmentExpression`.
  attribute Expression alternate;
};

// `FunctionExpression`,
// `GeneratorExpression`,
// `AsyncFunctionExpression`,
interface FunctionExpression : Node {
  attribute boolean isAsync;
  attribute boolean isGenerator;
  attribute AssertedScope? scope;
  attribute BindingIdentifier? name;
  attribute FormalParameters params;
  attribute FunctionBody body;
};

// `IdentifierReference`
interface IdentifierExpression : Node {
  attribute Identifier name;
};

interface NewExpression : Node {
  attribute Expression callee;
  attribute Arguments arguments;
};

interface NewTargetExpression : Node { };

interface ObjectExpression : Node {
  attribute FrozenArray<ObjectProperty> properties;
};

interface UnaryExpression : Node {
  attribute UnaryOperator operator;
  attribute Expression operand;
};

interface StaticMemberExpression : Node {
  // The object whose property is being accessed.
  attribute (Expression or Super) _object;
  // The name of the property to be accessed.
  attribute IdentifierName property;
};

// `TemplateLiteral`,
// `MemberExpression :: MemberExpression TemplateLiteral`,
// `CallExpression : CallExpression TemplateLiteral`
interface TemplateExpression : Node {
  // The second `MemberExpression` or `CallExpression`, if present.
  attribute Expression? tag;
  // The contents of the template. This list must be alternating
  // TemplateElements and Expressions, beginning and ending with
  // TemplateElement.
  attribute FrozenArray<(Expression or TemplateElement)> elements;
};

// `PrimaryExpression :: this`
interface ThisExpression : Node { };

// `UpdateExpression :: LeftHandSideExpression ++`,
// `UpdateExpression :: LeftHandSideExpression --`,
// `UpdateExpression :: ++ LeftHandSideExpression`,
// `UpdateExpression :: -- LeftHandSideExpression`
interface UpdateExpression : Node {
  // True for `UpdateExpression :: ++ LeftHandSideExpression` and
  // `UpdateExpression :: -- LeftHandSideExpression`, false otherwise.
  attribute boolean isPrefix;
  attribute UpdateOperator operator;
  attribute SimpleAssignmentTarget operand;
};

// `YieldExpression :: yield`,
// `YieldExpression :: yield AssignmentExpression`
interface YieldExpression : Node {
  // The `AssignmentExpression`, if present.
  attribute Expression? expression;
};

// `YieldExpression :: yield * AssignmentExpression`
interface YieldStarExpression : Node {
  attribute Expression expression;
};

interface AwaitExpression : Node {
  attribute Expression expression;
};


// other statements

interface BreakStatement : Node {
  attribute Label? label;
};

interface ContinueStatement : Node {
  attribute Label? label;
};

interface DebuggerStatement : Node { };

interface DoWhileStatement : Node {
  attribute Expression test;
  attribute Statement body;
};

interface EmptyStatement : Node { };

interface ExpressionStatement : Node {
  attribute Expression expression;
};

interface ForInOfBinding : Node {
  attribute VariableDeclarationKind kind;
  attribute Binding binding;
};

// `for ( LeftHandSideExpression in Expression ) Statement`,
// `for ( var ForBinding in Expression ) Statement`,
// `for ( ForDeclaration in Expression ) Statement`,
// `for ( var BindingIdentifier Initializer in Expression ) Statement`
interface ForInStatement : Node {
  // The expression or declaration before `in`.
  attribute (ForInOfBinding or AssignmentTarget) left;
  // The expression after `in`.
  attribute Expression right;
  attribute Statement body;
};

// `for ( LeftHandSideExpression of Expression ) Statement`,
// `for ( var ForBinding of Expression ) Statement`,
// `for ( ForDeclaration of Expression ) Statement`
interface ForOfStatement : Node {
  // The expression or declaration before `of`.
  attribute (ForInOfBinding or AssignmentTarget) left;
  // The expression after `of`.
  attribute Expression right;
  attribute Statement body;
};

// `for ( Expression ; Expression ; Expression ) Statement`,
// `for ( var VariableDeclarationlist ; Expression ; Expression ) Statement`
interface ForStatement : Node {
  // The expression or declaration before the first `;`, if present.
  attribute (VariableDeclaration or Expression)? init;
  // The expression before the second `;`, if present
  attribute Expression? test;
  // The expression after the second `;`, if present
  attribute Expression? update;
  attribute Statement body;
};

// `if ( Expression ) Statement`,
// `if ( Expression ) Statement else Statement`,
interface IfStatement : Node {
  attribute Expression test;
  // The first `Statement`.
  attribute Statement consequent;
  // The second `Statement`, if present.
  attribute Statement? alternate;
};

interface LabelledStatement : Node {
  attribute Label label;
  attribute Statement body;
};

interface ReturnStatement : Node {
  attribute Expression? expression;
};

// A `SwitchStatement` whose `CaseBlock` is
//   `CaseBlock :: { CaseClauses }`.
interface SwitchStatement : Node {
  attribute Expression discriminant;
  attribute FrozenArray<SwitchCase> cases;
};

// A `SwitchStatement` whose `CaseBlock` is
//   `CaseBlock :: { CaseClauses DefaultClause CaseClauses }`.
interface SwitchStatementWithDefault : Node {
  attribute Expression discriminant;
  // The `CaseClauses` before the `DefaultClause`.
  attribute FrozenArray<SwitchCase> preDefaultCases;
  // The `DefaultClause`.
  attribute SwitchDefault defaultCase;
  // The `CaseClauses` after the `DefaultClause`.
  attribute FrozenArray<SwitchCase> postDefaultCases;
};

interface ThrowStatement : Node {
  attribute Expression expression;
};

// `TryStatement :: try Block Catch`
interface TryCatchStatement : Node {
  attribute Block body;
  attribute CatchClause catchClause;
};

// `TryStatement :: try Block Finally`,
// `TryStatement :: try Block Catch Finally`
interface TryFinallyStatement : Node {
  // The `Block`.
  attribute Block body;
  // The `Catch`, if present.
  attribute CatchClause? catchClause;
  // The `Finally`.
  attribute Block finalizer;
};

interface WhileStatement : Node {
  attribute Expression test;
  attribute Statement body;
};

interface WithStatement : Node {
  attribute Expression _object;
  attribute Statement body;
};


// other nodes

interface Block : Node {
  attribute AssertedScope? scope;
  attribute FrozenArray<Statement> statements;
};

// `Catch`
interface CatchClause : Node {
  attribute Binding binding;
  attribute Block body;
};

// An item in a `DirectivePrologue`
interface Directive : Node {
  attribute string rawValue;
};

interface FormalParameters : Node {
  attribute FrozenArray<Parameter> items;
  attribute Binding? rest;
};

interface FunctionBody : Node {
  attribute FrozenArray<Directive> directives;
  attribute FrozenArray<Statement> statements;
};

// `FunctionDeclaration`,
// `GeneratorDeclaration`,
// `AsyncFunctionDeclaration`
interface FunctionDeclaration : Node {
  attribute boolean isAsync;
  attribute boolean isGenerator;
  attribute AssertedScope? scope;
  attribute BindingIdentifier name;
  attribute FormalParameters params;
  attribute FunctionBody body;
};

interface Script : Node {
  attribute FrozenArray<Directive> directives;
  attribute FrozenArray<Statement> statements;
};

interface SpreadElement : Node {
  attribute Expression expression;
};

// `super`
interface Super : Node { };

// `CaseClause`
interface SwitchCase : Node {
  attribute Expression test;
  attribute FrozenArray<Statement> consequent;
};

// `DefaultClause`
interface SwitchDefault : Node {
  attribute FrozenArray<Statement> consequent;
};

// `TemplateCharacters`
interface TemplateElement : Node {
  attribute string rawValue;
};

interface VariableDeclaration : Node {
  attribute VariableDeclarationKind kind;
  [NonEmpty] attribute FrozenArray<VariableDeclarator> declarators;
};

interface VariableDeclarator : Node {
  attribute Binding binding;
  attribute Expression? init;
};
  </code></pre>
</emu-clause>

<emu-clause id="ecmaify">
  <h1>Ecmaify</h1>
  <p>Ecmaify transforms Binary AST Nodes to ECMAScript Parse Nodes. It performs additional early error checking on top of existing ECMAScript early error semantics.</p>
  <p>A Parse Node may be <dfn>tag</dfn>ged as being transformed by a Binary AST Node. The original Binary AST Node is retrievable from tagged Parse Nodes.</p>
  <emu-note>Tagging Parse Nodes is used to introduce laziness at function body boundaries.</emu-note>
  <p>The naming convention of the Ecmaify abstract operations is:</p>
  <ul>
    <li>FooEcmaify always returns a Parse Node of the ECMAScript grammar production |Foo|.</li>
    <li>EcmaifyBar only takes Binary AST Node with interface `Bar` and returns Parse Nodes of varying ECMAScript grammar productions.</li>
    <li>Ecmaify is the central dispatcher that dispatches on the interface type of its input.</li>
  </ul>

  <emu-clause id="sec-hasmalformeddirectives" aoid="HasMalformedDirectives">
    <h1>HasMalformedDirectives ( _directives_, _nodes_ )</h1>
    <emu-alg>
      1. Assert: _directives_ is a `FrozenArray&lt;Directive>`.
      1. Assert: _nodes_ is a `FrozenArray&lt;Node>`.
      1. For each _node_ in _nodes_:
          1. If the _node_ is an `ExpressionStatement` and _node_.expression is a `StringLiteralExpression`:
              1. For each _dir_ in _directives_:
                  1. If _node_.`expression.value` is the same value as _dir_`.rawValue`, then return *false*.
              1. NOTE: This restriction disallows encoding directives as string literals.
      1. Return *true*.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-statementecmaify" aoid="StatementEcmaify">
    <h1>StatementEcmaify ( _stmt_ )</h1>
    <emu-alg>
      1. Assert: _stmt_ is a `Statement`.
      1. Let _n_ be Ecmaify(_stmt_).
      1. If _stmt_ is a `Block`, then:
          1. Set _n_ to |BlockStatement| : _n_.
      1. Else, if _stmt_ is an `IterationStatement`, then:
          1. Set _n_ to |BreakableStatement| : _n_.
      1. Else, return |Statement| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-statementlistecmaify" aoid="StatementListEcmaify">
    <h1>StatementListEcmaify ( _stmts_ )</h1>
    <emu-alg>
      1. Assert: _stmts_ is a `FrozenArray&lt;Statement>`.
      1. Let _list_ be an empty Parse Node.
      1. If _stmts_ has length 0, then:
          1. Let _emptyStmt_ be |StatementListItem| : |EmptyStatement|.
          1. Tag _emptyStmt_ as being produced by _f_.
          1. Set _list_ to |StatementList| : _emptyStmt_.
      1. For each _stmt_ in _stmts_:
          1. If _stmt_ is a `FunctionDeclaration`, then:
              1. Set _n_ to |HoistableDeclaration|: Ecmaify(_stmt_).
              1. Set _n_ to be |Declaration| : _n_.
          1. Else, set _n_ to be StatementEcmaify(_stmt_).
          1. Set _n_ to be |StatementListItem| : _n_.
          1. If _list_ is empty, then set _list_ to |StatementList| : _n_.
          1. Else, set _list_ to |StatementList| : _list_ _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-variabledeclarationlistecmaify" aoid="VariableDeclarationListEcmaify">
    <h1>VariableDeclarationListEcmaify ( _decls_ )</h1>
    <emu-alg>
      1. Assert: _decls_ is a `FrozenArray&lt;VariableDeclarator>`.
      1. Assert: _decls_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _decl_ in _decls_:
          1. Let _n_ be an empty Parse Node.
          1. Let _binding_ be Ecmaify(_decl_`.binding`).
          1. If _decl_`.init` is *null*, then:
              1. If _decl_`.binding` is not a `BindingIdentifier`, throw a *SyntaxError*.
              1. Set _n_ to |VariableDeclaration| : _binding_.
          1. Else:
              1. Let _init_ be Ecmaify(_decl_`.init`).
              1. Set _n_ to |VariableDeclaration| : _binding_ _init_.
          1. If _list_ is empty, set _list_ to |VariableDeclarationList| : _n_.
          1. Else, set _list_ to |VariableDeclarationList| : _list_ _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bindinglistecmaify" aoid="BindingListEcmaify">
    <h1>BindingListEcmaify ( _decls_ )</h1>
    <emu-alg>
      1. Assert: _decls_ is a `FrozenArray&lt;VariableDeclarator>`.
      1. Assert: _decls_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _decl_ in _decls_:
          1. Let _n_ be an empty Parse Node.
          1. Let _binding_ be Ecmaify(_decl_`.binding`).
          1. If _decl_`.init` is *null*, then:
              1. If _decl_`.binding` is not a `BindingIdentifier`, throw a *SyntaxError* exception.
              1. Set _n_ to |LexicalBinding| : _binding_.
          1. Else:
              1. Let _init_ be Ecmaify(_decl_`.init`).
              1. Set _n_ to |LexicalBinding| : _binding_ _init_.
          1. If _list_ is empty, set _list_ to |BindingList| : _n_.
          1. Else, set _list_ to |BindingList| : _list_ _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-elementlistecmaify" aoid="ElementListEcmaify">
    <h1>ElementListEcmaify ( _elems_ )</h1>
    <emu-alg>
      1. Assert: _elems_ is a `FrozenArray&lt;SpreadElement or Expression>`.
      1. Assert: _elems_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. Let _accumulatedElisions_ be an empty Parse Node.
      1. For each _elem_ in _elems_:
          1. Let _n_ be an empty Parse Node.
          1. If _elem_ is *null*, then:
              1. If _accumulatedElisions_ is empty, then set _accumulatedElisions_ to |Elision| : <emu-t>,</emu-t>.
              1. Else set _accumulatedElisions_ to |Elision| : _accumulatedElisions_ <emu-t>,</emu-t>.
          1. Else:
              1. If _elem_ is a SpreadElement, then:
                  1. Let _expr_ be AssigmentExpressionEcmaify(_elem_`.expression`).
                  1. Set _n_ to |SpreadElement| : <emu-t>...</emu-t> _expr_.
              1. Else set _n_ to AssignmentExpressionEcmaify(_elem_).
              1. If _list_ is empty, then:
                  1. If _accumulatedElisions_ is empty, then set _list_ to |ElementList| : _n_.
                  1. Else set _list_ to |ElementList| : _accumulatedElisions_ _n_.
              1. Else:
                  1. If _accumulatedElisions_ is empty, then set _list_ to |ElementList| : _list_ <emu-t>,</emu-t> _n_.
                  1. Else set _list_ to |ElementList| : _list_ <emu-t>,</emu-t> _accumulatedElisions_ _n_.
              1. Set _accumulatedElisions_ to an empty Parse Node.
      1. Return _list_ and _accumulatedElisions_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-formalparameterlistecmaify" aoid="FormalParameterListEcmaify">
    <h1>FormalParameterListEcmaify ( _params_ )</h1>
    <emu-alg>
      1. Assert: _params_ is a `FrozenArray&lt;Parameter>`.
      1. Assert: _params_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _param_ in _params_:
          1. Let _n_ be Ecmaify(_param_).
          1. If _list_ is empty, then set _list_ to |FormalParameterList| : _n_.
          1. Else, set _list_ to |FormalParameterList| : _list_ <emu-t>,</emu-t> _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-argumentlistecmaify" aoid="ArgumentListEcmaify">
    <h1>ArgumentListEcmaify ( _args_ )</h1>
    <emu-alg>
      1. Assert: _args_ is an `Arguments`.
      1. Assert: _args_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _arg_ in _args_:
          1. If _arg_ is a `SpreadElement`, then:
              1. Let _expr_ be AssignmentExpressionEcmaify(_arg_`.expression`).
              1. If _list_ is empty, then set _list_ to |ArgumentList| : <emu-t>...</emu-t> _expr_.
              1. Else, set _list_ to |ArgumentList| : _list_ <emu-t>,</emu-t> _expr_.
          1. Else:
              1. Let _expr_ be AssignmentExpressionEcmaify(_arg_).
              1. If _list_ is empty, then set _list_ to |ArgumentList| : _expr_.
              1. Else, set _list_ to |ArgumentList| : _list_ <emu-t>,</emu-t> _expr_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-propertydefinitionlistecmaify" aoid="PropertyDefinitionListEcmaify">
    <h1>PropertyDefinitionListEcmaify ( _props_ )</h1>
    <emu-alg>
      1. Assert: _props_ is a `FrozenArray&lt;ObjectProperty`.
      1. Assert: _props_ does not have length 0.
      1. Let _list_ be an empty Parse Node.
      1. For each _prop_ in _props_:
          1. Let _n_ be an empty Parse Node.
          1. If _prop_ is a `MethodDefinition`, then set _n_ to |PropertyDefinition| : Ecmaify(_prop_).
          1. Else, set _n_ to Ecmaify(_prop_).
          1. If _list_ is empty, then set _list_ to |PropertyDefinitionList| : _n_.
          1. Else, set _list_ to |PropertyDefinitionList| : _list_ <emu-t>,</emu-t> _n_.
      1. Return _list_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-caseclauseecmaify" aoid="CaseClauseEcmaify">
    <h1>CaseClauseEcmaify ( _case_ )</h1>
    <emu-alg>
      1. Assert: _case_ is a `SwitchCase`.
      1. Let _expr_ be ExpressionEcmaify(_case_.test).
      1. Let _clause_ be an empty Parse Node.
      1. If _case_`.consequent` has length 0, then:
          1. Set _clause_ to |CaseClause| : <emu-t>case</emu-t> _expr_ <emu-t>:</emu-t>.
      1. Else:
          1. Let _stmts_ be StatementListEcmaify(_case_`.consequent`).
          1. Set _clause_ to |CaseClause| : <emu-t>case</emu-t> _expr_ <emu-t>:</emu-t> _stmts_.
      1. Return _clause_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-defaultclauseecmaify" aoid="DefaultClauseEcmaify">
    <h1>DefaultClauseEcmaify ( _case_ )</h1>
    <emu-alg>
      1. Assert: _case_ is a `SwitchDefault`.
      1. Let _clause_ be an empty Parse Node.
      1. If _case_`.consequent` has length 0, then:
          1. Set _clause_ to |CaseClause| : <emu-t>default</emu-t> <emu-t>:</emu-t>.
      1. Else:
          1. Let _stmts_ be StatementListEcmaify(_case_.consequent).
          1. Set _clause_ to |CaseClause| : <emu-t>default</emu-t> <emu-t>:</emu-t> _stmts_.
      1. Return _clause_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-caseclausesecmaify" aoid="CaseClausesEcmaify">
    <h1>CaseClausesEcmaify ( _cases_ )</h1>
    <emu-alg>
      1. Assert: _cases_ is a `FrozenArray&lt;SwitchCase>`.
      1. Assert: _cases_ does not have length 0.
      1. Let _clauses_ be an empty Parse Node.
      1. For _case_ in _cases_:
          1. Let _clause_ be CaseClauseEcmaify(_case_).
          1. If _clauses_ is empty, then set _clauses_ to |CaseClauses| : _clause_.
          1. Else, set _clauses_ to |CaseClauses| : _clauses_ _clause_.
      1. Return _clauses_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-argumentsecmaify" aoid="ArgumentsEcmaify">
    <h1>ArgumentsEcmaify ( _args_ )</h1>
    <emu-alg>
      1. Assert: _args_ is an `Arguments`.
      1. If _args_ has length 0, then return |Arguments| : <emu-t>(</emu-t> <emu-t>)</emu-t>.
      1. Else:
          1. Let _list_ be ArgumentListEcmaify(_call_`.arguments`).
          1. Return |Arguments| : <emu-t>(</emu-t> _list_ <emu-t>)</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-primaryexpressionecmaify" aoid="PrimaryExpressionEcmaify">
    <h1>PrimaryExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `ThisExpression`, then return Ecmaify(_e_).
      1. Else if _pn_ is an `IdentifierExpression`, a `Literal`, an `ArrayExpression`, an `ObjectExpression`, a `FunctionExpression`, a `ClassExpression`, a `LiteralRegExpExpression`, or a `TemplateExpression`, then return |PrimaryExpression| : Ecmaify(_e_).
      1. Else:
          1. Let _parenthesized_ be |ParenthesizedExpression| : <emu-t>(</emu-t> ExpressionEcmaify(_e_) <emu-t>)</emu-t>.
          1. Return |PrimaryExpression| : _parenthesized_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-memberexpressionecmaify" aoid="MemberExpressionEcmaify">
    <h1>MemberExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `ComputedMemberExpression`, a `StaticMemberExpression`, a `NewTargetExpression`, or a `NewExpression`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be PrimaryExpressionEcmaify(_e_).
          1. Return |MemberExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-lefthandsideexpressionecmaify" aoid="LeftHandSideExpressionEcmaify">
    <h1>LeftHandSideExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `NewExpression`, then:
          1. Let _n_ be |NewExpression| : Ecmaify(_e_).
          1. Return |LeftHandSideExpression| : _n_.
      1. Else, if _e_ is a `CallExpression`, then return |LeftHandExpression| : Ecmaify(_e_).
      1. Else:
          1. Let _n_ be |NewExpression| : MemberExpressionEcmaify(_e_).
          1. Return |LeftHandSideExpression|: _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-updateexpressionecmaify" aoid="UpdateExpressionEcmaify">
    <h1>UpdateExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is an `UpdateExpression`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be LeftHandSideExpressionEcmaify(_e_).
          1. Return |UpdateExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-unaryexpressionecmaify" aoid="UnaryExpressionEcmaify">
    <h1>UnaryExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `UnaryExpression`, then return Ecmaify(_e_).
      1. Else, if _e_ is an `AwaitExpression`, then:
          1. Let _n_ be Ecmaify(_e_).
          1. Return |UnaryExpression| : _n_.
      1. Else:
          1. Let _n_ be UpdateExpressionEcmaify(_e_).
          1. Return |UnaryExpresison| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-exponentiationexpressionecmaify" aoid="ExponentiationExpressionEcmaify">
    <h1>ExponentiationExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"||"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be UnaryExpressionEcmaify(_e_).
          1. Return |ExponentiationExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-multiplicativeexpressionecmaify" aoid="MultiplicativeExpressionEcmaify">
    <h1>MultiplicativeExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"|"`, `"/"`, or `"%"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be ExponentiationExpressionEcmaify(_e_).
          1. Return |MultiplicativeExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-additiveexpressionecmaify" aoid="AdditiveExpressionEcmaify">
    <h1>AdditiveExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"+"` or `"-"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be MultiplicativeExpressionEcmaify(_e_).
          1. Return |AdditiveExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-shiftexpressionecmaify" aoid="ShiftExpressionEcmaify">
    <h1>ShiftExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"<<"`, `">>"`, or `">>>"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be AdditiveExpressionEcmaify(_e_).
          1. Return |ShiftExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-relationalexpressionecmaify" aoid="RelationExpressionEcmaify">
    <h1>RelationalExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"<"`, `">"`, `"<="`, `">="`, `"instanceof"`, or `"in"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be ShiftExpressionEcmaify(_e_).
          1. Return |RelationalExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-equalityexpressionecmaify" aoid="EqualityExpressionEcmaify">
    <h1>EqualityExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"=="`, `"!="`, `"==="`, or `"!=="`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be RelationalExpressionEcmaify(_e_).
          1. Return |EqualityExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bitwiseandexpressionecmaify" aoid="BitwiseANDExpressionEcmaify">
    <h1>BitwiseANDExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"&"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be EqualityExpressionEcmaify(_e_).
          1. Return |BitwiseANDExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bitwisexorexpressionecmaify" aoid="BitwiseXORExpressionEcmaify">
    <h1>BitwiseXORExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"^"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be BitwiseANDExpressionEcmaify(_e_).
          1. Return |BitwiseXORExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-bitwiseorexpressionecmaify" aoid="BitwiseORExpressionEcmaify">
    <h1>BitwiseORExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"|"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be BitwiseXORExpressionEcmaify(_e_).
          1. Return |BitwiseORExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-logicalandexpressionecmaify" aoid="LogicalANDExpressionEcmaify">
    <h1>LogicalANDExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"&&"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be BitwiseORExpressionEcmaify(_e_).
          1. Return |LogicalANDExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-logicalorexpressionecmaify" aoid="LogicalORExpressionEcmaify">
    <h1>LogicalORExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `"||"`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be LogicalANDExpressionEcmaify(_e_).
          1. Return |LogicalORExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-conditionalexpressionecmaify" aoid="ConditionalExpressionEcmaify">
    <h1>ConditionalExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `ConditionalExpression`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be LogicalORExpressionEcmaify(_e_).
          1. Return |ConditionalExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-assignmentexpressionecmaify" aoid="AssignmentExpressionEcmaify">
    <h1>AssignmentExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `YieldExpression`, an `ArrowExpression`, an `AssignmentExpression`, or a `CompoundAssignmentExpression`, then return |AssignmentExpression| : Ecmaify(_e_).
      1. Else:
          1. Let _n_ be ConditionalExpressionEcmaify(_e_).
          1. Return |AssignmentExpression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-expressionecmaify" aoid="ExpressionEcmaify">
    <h1>ExpressionEcmaify ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `Expression`.
      1. If _e_ is a `BinaryExpression` and _e_`.operator` is `","`, then return Ecmaify(_e_).
      1. Else:
          1. Let _n_ be AssignmentExpressionEcmaify(_e_).
          1. Return |Expression| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-lazyfunctionbodyecmaify" aoid="LazyFunctionBodyEcmaify">
    <h1>LazyFunctionBodyEcmaify ( _f_ )</h1>
    <emu-alg>
      1. NOTE: When an |EmptyStatement| tagged as being produced by a Binary AST FunctionBody is evaluated at runtime, Ecmaify is run on the function at that time.
      1. Assert: _f_ is a `FunctionBody` or an `Expression`.
      1. Let _emptyStmt_ be |StatementListItem| : |EmptyStatement|.
      1. Tag _emptyStmt_ as being produced by _f_.
      1. Let _stmts_ be |StatementList| : _emptyStmt_.
      1. Return |FunctionBody| : _stmts_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyscript" aoid="EcmaifyScript">
    <h1>EcmaifyScript ( _s_ )</h1>
    <emu-alg>
      1. Assert: _s_ is a `Script`.
      1. If HasMalformedDirectives(_s_`.directives`, _s_`.statements`) is *false*, throw a *SyntaxError* exception.
      1. Let _dirsStmts_ be _s_`.directives` prepended to _s_`.statements`.
      1. If _s_`.directives_` has length 0 and _s_`.statements` has length 0, then:
          1. return |Script| :
      1. Else:
          1. Let _dirStmts_ be _s_`.directives` concatenated with _s_`.statements`.
          1. Let _stmts_ be StatementListEcmaify(_dirStmts_).
          1. Return |Script| : _stmts_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifymodule" aoid="EcmaifyModule">
    <h1>EcmaifyModule ( _m_ )</h1>
    <emu-alg>
      1. Assert: _m_ is a `Module`.
      1. TODO.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyfunctionbody" aoid="EcmaifyFunctionBody">
    <h1>EcmaifyFunctionBody ( _f_ )</h1>
    <emu-alg>
      1. NOTE: This is called when an |EmptyStatement| tagged as being produced by a Binary AST FunctionBody or Expression is evaluated at runtime.
      1. Assert: _f_ is a `FunctionBody` or an `Expression`.
      1. If _f_ is a `FunctionBody`, then:
          1. If HasMalformedDirectives(_f_`.directives`, _f_`.statements`) is *false*, throw a *SyntaxError* exception.
          1. Let _dirStmts_ be _f_`.directives` concatenated with _f_`.statements`.
          1. Let _stmts_ be StatementListEcmaify(_dirStmts_).
          1. Return |FunctionBody| : _stmts_.
      1. Else return ExpressionEcmaify(_f_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyblock" aoid="EcmaifyBlock">
    <h1>EcmaifyBlock ( _b_ )</h1>
    <emu-alg>
      1. Assert: _b_ is a `Block`.
      1. Let _stmts_ be StatementListEcmaify(_b_`.statements`).
      1. Return |Block| : <emu-t>{</emu-t> _stmts_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifybreakstatement" aoid="EcmaifyBreakStatement">
    <h1>EcmaifyBreakStatement ( _brk_ )</h1>
    <emu-alg>
      1. Assert: _brk_ is a `BreakStatement`.
      1. If _brk_`.label` is *null*, then return |BreakStatement| : <emu-t>break</emu-t> <emu-t>;</emu-t>.
      1. Else, return |BreakStatement| : <emu-t>break</emu-t> _brk_`.label` <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycontinuestatement" aoid="EcmaifyContinueStatement">
    <h1>EcmaifyContinueStatement ( _cont_ )</h1>
    <emu-alg>
      1. Assert: _cont_ is a `ContinueStatement`.
      1. If _cont_`.label` is *null*, then:
          1. Return |ContinueStatement| : <emu-t>continue</emu-t> <emu-t>;</emu-t>.
      1. Else, return |ContinueStatement| : <emu-t>continue</emu-t> _cont_.label <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyclassdeclaration" aoid="EcmaifyClassDeclaration">
    <h1>EcmaifyClassDeclaration (_cls_ )</h1>
    <emu-alg>
      1. Assert: _cls_ is a `ClassDeclaration`.
      1. TODO.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifydebuggerstatement" aoid="EcmaifyDebuggerStatement">
    <h1>EcmaifyDebuggerStatement ( _dbg_ )</h1>
    <emu-alg>
      1. Assert: _dbg_ is a `DebuggerStatement`.
      1. Return |DebuggerStatement| : <emu-t>debugger</emu-t> <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyemptystatement" aoid="EcmaifyEmptyStatement">
    <h1>EcmaifyEmptyStatement ( _e_ )</h1>
    <emu-alg>
      1. Assert: _e_ is an `EmptyStatement`.
      1. Return |EmptyStatement| : <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyexpressionstatement" aoid="EcmaifyExpressionStatement">
    <h1>EcmaifyExpressionStatement ( _expr_ )</h1>
    <emu-alg>
      1. Assert: _expr_ is an `ExpressionStatement`.
      1. Return |ExpressionStatement| : Ecmaify(_expr_`.expression`) <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyfunctiondeclaration" aoid="EcmaifyFunctionDeclaration">
    <h1>EcmaifyFunctionDeclaration ( _func_ )</h1>
    <emu-alg>
      1. Assert: _func_ is a `FunctionDeclaration`.
      1. Let _params_ be Ecmaify(_func_`.params`).
      1. If _func_`.isAsync` is *true*, then:
          1. Let _body_ be |AsyncFunctionBody| : LazyFunctionBodyEcmaify(_func_`.body`).
          1. Return |AsyncFunctionDeclaration| : <emu-t>async</emu-t> <emu-t>function</emu-t> _func_`.name` <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else, if _func_`.isGenerator` is *true*, then:
          1. Let _body_ be |GeneratorBody| : LazyFunctionBodyEcmaify(_func_`.body`).
          1. Return |GeneratorDeclaration| : <emu-t>function</emu-t> <emu-t>*</emu-t> _func_`.name` <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else:
          1. Let _body_ be LazyFunctionBodyEcmaify(_func_`.body`).
          1. Return |FunctionDeclaration| : <emu-t>function</emu-t> _func_`.name` <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyifstatement" aoid="EcmaifyIfStatement">
    <h1>EcmaifyIfStatement ( _if_ )</h1>
    <emu-alg>
      1. Assert: _if_ is an `IfStatement`.
      1. Let _test_ be Ecmaify(_if_`.test`).
      1. Let _then_ be Ecmaify(_if_`.consequent`).
      1. If _if_`.alternate` is *null*, then:
          1. Return |IfStatement| : <emu-t>if</emu-t> <emu-t>(</emu-t> _test_ <emu-t>)</emu-t> _then_.
      1. Else, return |IfStatement| : <emu-t>if</emu-t> <emu-t>(</emu-t> _test_ <emu-t>)</emu-t> _then_ <emu-t>else</emu-t> StatementEcmaify(_if_`.alternate`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifydowhilestatement" aoid="EcmaifyDoWhileStatement">
    <h1>EcmaifyDoWhileStatement ( _doWhile_  )</h1>
    <emu-alg>
      1. Assert: _doWhile_ is a `DoWhileStatement`.
      1. Let _test_ be ExpressionEcmaify(_doWhile_`.test`).
      1. Let _body_ be StatementEcmaify(_doWhile_`.body`).
      1. Return |IterationStatement| : <emu-t>do</emu-t> _body_ <emu-t>while</emu-t> <emu-t>(</emu-t> _test_ <emu-t>)</emu-t> <emu-t>;</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyforinstatement" aoid="EcmaifyForInStatement">
    <h1>EcmaifyForInStatement ( _forIn_ )</h1>
    <emu-alg>
      1. Assert: _forIn_ is a `ForInStatement`.
      1. Let _left_ be an empty Parse Node.
      1. If _forIn_`.left` is a ForInOfBinding, then set _left_ to Ecmaify(_forIn_`.left`).
      1. Else, set _left_ to LeftHandSideExpressionEcmaify(_forIn_`.left`).
      1. Let _right_ be AssignmentExpressionEcmaify(_forIn_`.right`).
      1. Let _body_ be StatementEcmaify(_forIn_`.body`).
      1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> _left_ <emu-t>in</emu-t> _right_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyforofstatement" aoid="EcmaifyForOfStatement">
    <h1>EcmaifyForOfStatement ( _forOf_ )</h1>
    <emu-alg>
      1. Assert: _forOf_ is a `ForOfStatement`.
      1. Let _left_ be an empty Parse Node.
      1. If _forOf_`.left` is a ForInOfBinding, then set _left_ to Ecmaify(_forOf_`.left`).
      1. Else, set _left_ to LeftHandSideExpressionEcmaify(_forOf_`.left`).
      1. Let _right_ be AssignmentExpressionEcmaify(_forOf_`.right`).
      1. Let _body_ be StatementEcmaify(_forOf_`.body`).
      1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> _left_ <emu-t>of</emu-t> _right_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyforstatement" aoid="EcmaifyForStatement">
    <h1>EcmaifyForStatement ( _for_ )</h1>
    <emu-alg>
      1. Assert: _for_ is a `ForStatement`.
      1. Let _init_, _test_, and _update_ be empty Parse Nodes.
      1. If _for_`.init` is not *null*, then:
          1. If _for_`.init` is a `VariableDeclaration`, then:
              1. If _for_`.init.kind` is `"var"`, then set _init_ to the partial Parse Node <emu-t>var</emu-t> VariableDeclarationEcmaify(_for_`.init.declarators`).
              1. Else set _init_ to |LexicalDeclaration| : Ecmaify(_for_`.init.kind`) BindingListEcmaify(_for_`.init.declarators`).
          1. Else set _init_ to LeftHandSideExpressionEcmaify(_for_`.init`).
      1. If _for_`.test` is not null, then set _test_ to ExpressionEcmaify(_for_`.test`).
      1. If _for_`.update` is not null, then set _update_ to ExperssionEcmaify(_for_`.test`).
      1. Let _body_ be StatementEcmaify(_for_`.body`).
      1. Return |IterationStatement| : <emu-t>for</emu-t> <emu-t>(</emu-t> _init_ <emu-t>;</emu-t> _test_ <emu-t>;</emu-t> _update_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifywhilestatement" aoid="EcmaifyWhileStatement">
    <h1>EcmaifyWhileStatement ( _while_ )</h1>
    <emu-alg>
      1. Assert: _while_ is a `WhileStatement`.
      1. Let _test_ be ExpressionEcmaify(_while_`.test`).
      1. Let _body_ be StatementEcmaify(_while_`.body`).
      1. Return |IterationStatement| : <emu-t>while</emu-t> <emu-t>(</emu-t> _test_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifylabelledstatement" aoid="EcmaifyLabelledStatement">
    <h1>EcmaifyLabelledStatement ( _labelled_ )</h1>
    <emu-alg>
      1. Assert _labelled_ is a `LabelledStatement`.
      1. Let _body_ be an empty Parse Node.
      1. If _labelled_`.body` is a `FunctionDeclaration`, then:
          1. If _labelled_`.body.isAsync` is true or _labelled_`.body.isGenerator` is true, then throw a *SyntaxError* exception.
          1. Set _body_ to Ecmaify(_labelled_`.body`).
      1. Else, set _body_ to StatementEcmaify(_labelled_`.body`).
      1. Let _item_ be |LabelledItem| : _body_.
      1. Return |LabelledStatement| : _labelled_`.label` <emu-t>:</emu-t> _item_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyreturnstatement" aoid="EcmaifyReturnStatement">
    <h1>EcmaifyReturnStatement ( _ret_ )</h1>
    <emu-alg>
      1. Assert: _ret_ is a `ReturnStatement`.
      1. If _ret_`.expression` is *null*, then:
          1. Return |ReturnStatement| : <emu-t>return</emu-t> <emu-t>;</emu-t>.
      1. Else, return |ReturnStatement| : <emu-t>return</emu-t> ExpressionEcmaify(_ret_`.expression`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyswitchstatement" aoid="EcmaifySwitchStatement">
    <h1>EcmaifySwitchStatement ( _switch_ )</h1>
    <emu-alg>
      1. Assert: _switch_ is a `SwitchStatement`.
      1. Let _expr_ be ExpressionEcmaify(_switch_`.discriminant`).
      1. Let _block_ be an empty Parse Node.
      1. If _switch_`.cases` has length 0, then set _block_ to |CaseBlock| : <emu-t>{</emu-t> <emu-t>}</emu-t>.
      1. Else:
          1. Let _clauses_ be CaseClausesEcmaify(_switch_`.cases`).
          1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _clauses_ <emu-t>}</emu-t>.
      1. Return |SwitchStatement| : <emu-t>switch</emu-t> <emu-t>(</emu-t> _expr_ <emu-t>)</emu-t> _block_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyswitchstatementwithdefault" aoid="EcmaifySwitchStatementWithDefault">
    <h1>EcmaifySwitchStatementWithDefault ( _switch_ )</h1>
    <emu-alg>
      1. Assert: _switch_ is a `SwitchStatementWithDefault`.
      1. Let _expr_ be ExpressionEcmaify(_switch_`.discriminant`).
      1. Let _defaultClause_ be DefaultClauseEcmaify(_switch_`.defaultCase`).
      1. Let _block_ be an empty Parse Node.
      1. If _switch_`.preDefaultCases` has length 0, then:
          1. If _switch_`.postDefaultCases` has length 0, then:
              1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _defaultClause_ <emu-t>}</emu-t>.
          1. Else:
              1. Let _postDefaultClauses_ be CaseClausesEcmaify(_switch_`.postDefaultCases`).
              1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _defaultClause_ _postDefaultClauses_ <emu-t>}</emu-t>.
      1. Else if _switch_`.postDefaultCases` has length 0, then:
          1. Let _preDefaultClauses_ be CaseClausesEcmaify(_switch_`.preDefaultCases`).
          1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _preDefaultClauses_ _defaultClause_ <emu-t>}</emu-t>
      1. Else:
          1. Let _preDefaultClauses_ be CaseClausesEcmaify(_switch_`.preDefaultCases`).
          1. Let _postDefaultClauses_ be CaseClausesEcmaify(_switch_`.postDefaultCases`).
          1. Set _block_ to |CaseBlock| : <emu-t>{</emu-t> _preDefaultClauses_ _defaultClause_ _postDefaultClauses_ <emu-t>}</emu-t>.
      1. Return |SwitchStatement| : <emu-t>switch</emu-t> <emu-t>(</emu-t> _expr_ <emu-t>)</emu-t> _block_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifythrowstatement" aoid="EcmaifyThrowStatement">
    <h1>EcmaifyThrowStatement ( _throw_ )</h1>
    <emu-alg>
      1. Assert: _throw_ is a `ThrowStatement`.
      1. Return |ThrowStatement| : <emu-t>throw</emu-t> ExpressionEcmaify(_throw_`.expression`).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifytrycatch" aoid="EcmaifyTryCatch">
    <h1>EcmaifyTryCatch ( _tryCatch_ )</h1>
    <emu-alg>
      1. Assert: _tryCatch_ is a `TryCatchStatement`.
      1. Let _block_ be Ecmaify(_tryCatch_`.body`).
      1. Let _catch_ be Ecmaify(_tryCatch_`.catchClause`).
      1. Return |TryStatement| : <emu-t>try</emu-t> _block_ _catch_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifytryfinally" aoid="EcmaifyTryFinally">
    <h1>EcmaifyTryFinally ( _tryFinally_ )</h1>
    <emu-alg>
      1. Assert: _tryFinally_ is a `TryFinallyStatement`.
      1. Let _block_ be Ecmaify(_tryCatch_`.body`).
      1. Let _finally_ be |Finally| : <emu-t>finally</emu-t> Ecmaify(_tryFinally_`.finalizer`).
      1. If _tryFinally_`.catch` is *null*, then:
          1. Return |TryStatement| : <emu-t>try</emu-t> _block_ _finally_.
      1. Else:
          1. Let _catch_ be Ecmaify(tryCatch.catchClause).
          1. Return |TryStatement| : <emu-t>try</emu-t> _block_ _catch_ _finally_.
  </emu-clause>

  <emu-clause id="sec-ecmaifywithstatement" aoid="EcmaifyWithStatement">
    <h1>EcmaifyWithStatement ( _with_ )</h1>
    <emu-alg>
      1. Assert: _with_ is a `WithStatement`.
      1. Let _expr_ be ExpressionEcmaify(_with_`._object`).
      1. Let _body_ be StatementEcmaify(_with_`.body`).
      1. Return |WithStatement| : <emu-t>with</emu-t> <emu-t>(</emu-t> _expr_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralbooleanexpression" aoid="EcmaifyLiteralBooleanExpression">
    <h1>EcmaifyLiteralBooleanExpression ( _litBool_ )</h1>
    <emu-alg>
      1. Assert: _litBool_ is a `LiteralBooleanExpression`.
      1. Let _l_ be an empty Parse Node.
      1. If _litBool_`.value` is *true*, then set _l_ to |BooleanLiteral| : <emu-t>true</emu-t>.
      1. Else, set _l_ to |BooleanLiteral| : <emu-t>false</emu-t>.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralinfinityexpression" aoid="EcmaifyLiteralInfinityExpression">
    <h1>EcmaifyLiteralInfinityExpression ( _litInfty_ )</h1>
    <emu-alg>
      1. NOTE: The full tree of numeric literals is elided here and left as an exercise to the reader.
      1. NOTE: This node is not for the `Infinity` identifier, but for literal decimals whose mathematical values exceed the bounds of IEEE doubles.
      1. Assert: _litInfty_ is a `LiteralInfinityExpresion`.
      1. Let _l0_ be |DecimalLiteral| : <emu-t>2e308</emu-t>.
      1. Let _l1_ be |NumericLiteral| : _l0_.
      1. Return |Literal| : _l1_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralnullexpression" aoid="EcmaifyLiteralNullExpression">
    <h1>EcmaifyLiteralNullExpression ( _litNull_ )</h1>
    <emu-alg>
      1. Assert: _litNull_ is a `LiteralNullExpression`.
      1. Let _l_ be |NullLiteral| : <emu-t>null</emu-t>.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralnumericexpression" aoid="EcmaifyLiteralNumericExpression">
    <h1>EcmaifyLiteralNumericExpression ( _litNumeric_ )</h1>
    <emu-alg>
      1. NOTE: The full tree of numeric literals is elided here and left as an exercise to the reader.
      1. NOTE: The value in _litNumeric_ is positive, non-NaN, and finite.
      1. Assert: _litNumeric_ is a `LiteralNumericExpression`.
      1. Let _l_ be |DecimalLiteral| : _litNumeric_`.value`.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralregexpexpression" aoid="EcmaifyLiteralRegExpExpression">
    <h1>EcmaifyLiteralRegExpExpression ( _litRegexp_ )</h1>
    <emu-alg>
      1. NOTE: The full tree of regular expression literals is elided here and left as an exercise to the reader.
      1. Assert: _litRegExp_ is a `LiteralRegExpExpression`.
      1. Let _body_ be |RegularExpressionBody| : _litRegexp_`.pattern`.
      1. Let _flags_ be |RegularExpressionFlags| : _litRegexp_`.flags`.
      1. Return |RegularExpressionLiteral| : <emu-t>/</emu-t> _body_ <emu-t>/</emu-t> _flags_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralstringexpression" aoid="EcmaifyLiteralStringExpression">
    <h1>EcmaifyLiteralStringExpression ( _litStr_ )</h1>
    <emu-alg>
      1. Assert: _litStr_ is a `LiteralStringExpression`.
      1. Let _v_ be the value of _litStr_`.value` escaped for double quotes.
      1. Let _l_ be |StringLiteral| : <emu-t>&#34;</emu-t> _v_ <emu-t>&#34;</emu-t>.
      1. Return |Literal| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyarrayexpression" aoid="EcmaifyArrayExpression">
    <h1>EcmaifyArrayExpression ( _litArray_ )</h1>
    <emu-alg>
      1. Assert: _litArray_ is an `ArrayExpression`.
      1. If _litArray_`.elements` has length 0, then:
          1. Return |ArrayLiteral| : <emu-t>[</emu-t> <emu-t>]</emu-t>.
      1. Let and _elementList_ and _elisions_ be the results of ElementListEcmaify(_litArray_`.elements`).
      1. If _elementList_ is empty:
          1. Assert: _elisions_ is not empty.
          1. Return |ArrayLiteral| : <emu-t>[</emu-t> _elisions_ <emu-t>]</emu-t>.
      1. Else:
          1. If _elisions_ is empty, then return |ArrayLiteral| : <emu-t>[</emu-t> _elementList_ <emu-t>]</emu-t>.
          1. Else return |ArrayLiteral| : <emu-t>[</emu-t> _elementList_ <emu-t>,</emu-t> _elisions_ <emu-t>]</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyarrowexpression" aoid="EcmaifyArrowExpression">
    <h1>EcmaifyArrowExpression ( _litArrow_ )</h1>
    <emu-alg>
      1. NOTE: Arrow expressions are canonicalized to use parenthesized parameters and braced bodies.
      1. Assert: _litArrow_ is an `ArrowExpression`.
      1. Let _params0_ be |UniqueFormalParameters| : Ecmaify(_litArrow_`.params`).
      1. Let _params_ be |ArrowFormalParameters| : <emu-t>(</emu-t> _params0_ <emu-t>(</emu-t>.
      1. Let _lazyBody_ be LazyFunctionBodyEcmaify(_litArrow_`.body`).
      1. If _litArrow_`.isAsync` is *true*, then:
          1. Let _asyncHead_ be |AsyncArrowHead| : <emu-t>async</emu-t> _params_.
          1. Let _asyncBody0_ be |AsyncFunctionBody| : _lazyBody_.
          1. Let _asyncBody_ be |AsyncConciseBody| : <emu-t>{</emu-t> _asyncBody0_ <emu-t>}</emu-t>.
          1. Return |AsyncArrowFunction| : _asyncHead_ <emu-t>=&gt;</emu-t> _asyncBody_.
      1. Else:
          1. Let _body_ be |ConciseBody| : <emu-t>{</emu-t> _lazyBody_ <emu-t>}</emu-t>.
          1. Return |ArrowFunction| : _params_ <emu-t>=&gt;</emu-t> _body_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyassignmentexpression" aoid="EcmaifyAssignmentExpression">
    <h1>EcmaifyAssignmentExpression ( _assign_ )</h1>
    <emu-alg>
      1. Assert: _assign_ is an `AssignmentExpression`.
      1. Let _lhs_ be LeftHandSideExpressionEcmaify(_assign_`.binding`).
      1. Let _rhs_ be AssignmentExpressionEcmaify(_assign_`.expression`).
      1. Return |AssignmentExpression| : _lhs_ <emu-t>=</emu-t> _rhs_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifybinaryexpression" aoid="EcmaifyBinaryExpression">
    <h1>EcmaifyBinaryExpression ( _bin_ )</h1>
    <emu-alg>
      1. Assert: _bin_ is a `BinaryExpression`.
      1. If _bin_`.operator` is `","`, then:
          1. Let _left_ be ExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be AssignmentExpressionEcmaify(_bin_`.right`).
          1. Return |Expression| : _left_ <emu-t>,</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"||"`, then:
          1. Let _left_ be LogicalOREcmaify(_bin_`.left`).
          1. Let _right_ be LogicalANDEcmaify(_bin_`.right`).
          1. Return |LogicalORExpression| : _left_ <emu-t>||</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"&&"`, then:
          1. Let _left_ be LogicalANDEcmaify(_bin_`.left`).
          1. Let _right_ be BitwiseOREcmaify(_bin_`.right`).
          1. Return |LogicalANDExpression| : _left_ <emu-t>&&</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"|"`, then:
          1. Let _left_ be BitwiseOREcmaify(_bin_`.left`).
          1. Let _right_ be BitwiseXOREcmaify(_bin_`.right`).
          1. Return |BitwiseORExpression| : _left_ <emu-t>|</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"^"`, then:
          1. Let _left_ be BitwiseXOREcmaify(_bin_`.left`).
          1. Let _right_ be BitwiseANDEcmaify(_bin_`.right`).
          1. Return |BitwiseXORExpression| : _left_ <emu-t>^</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"&"`, then:
          1. Let _left_ be BitwiseANDEcmaify(_bin_`.left`).
          1. Let _right_ be EqualityExpressionEcmaify(_bin_`.right`).
          1. Return |BitwiseANDExpression| : _left_ <emu-t>&</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"=="`, `"!="`, `"==="`, or `"!=="`, then:
          1. Let _left_ be EqualityExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be RelationalExpressionEcmaify(_bin_`.right`).
          1. If _bin_`.operator` is `"=="`, then return |EqualityExpression| : _left_ <emu-t>==</emu-t> _right_.
          1. Else, if _bin_`.operator` is `"!="`, then return |EqualityExpression| : _left_ <emu-t>!=</emu-t> _right_.
          1. Else, if _bin_`.operator` is `"==="`, then return |EqualityExpression| : _left_ <emu-t>===</emu-t> _right_.
          1. Else return |EqualityExpression| : _left_ <emu-t>!==</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"<"`, `">"`, `"<="`, `">="`, `"instanceof"`, or `"in"`, then:
          1. Let _left_ be RelationExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ShiftExpressionEcmaify(_bin_`.right`).
          1. If _bin_`.operator` is `"<"` return |RelationalExpression| : _left_ <emu-t>&lt;</emu-t> _right_.
          1. Else, if _bin_`.operator` is `">"`, then return |RelationalExpression| : _left_ <emu-t>&gt;</emu-t> _right_.
          1. Else, if _bin_`.operator` is `"<="` return |RelationalExpression| : _left_ <emu-t>&lt;=</emu-t> _right_.
          1. Else, if _bin_`.operator` is `">="`, then return |RelationalExpression| : _left_ <emu-t>&gt;=</emu-t> _right_.
          1. Else, if _bin_`.operator` is `"instanceof"`, then return |RelationalExpression| : _left_ <emu-t>instanceof</emu-t> _right_.
          1. Else return |RelationalExpression| : _left_ <emu-t>in</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"<<"`, `">>"`, or ">>>"`, then:
          1. Let _left_ be ShiftExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be AdditiveExpressionEcmaify(_bin_`.right`).
          1. If _bin_`.operator` is `"<<"`, then return |ShiftExpression| : _left_ <emu-t>&lt;&lt;</emu-t> _right_.
          1. Else, if _bin_`.operator` is `">>"`, then return |ShiftExpression| : _left_ <emu-t>&gt;&gt;</emu-t> _right_.
          1. Else return |ShiftExpression| : _left_ <emu-t>&gt;&gt;&gt;</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"+"` or `"-"`, then:
          1. Let _left_ be AdditiveExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be MultiplicativeExpressionEcmaify(_bin_`.right`).
          1. If _bin_`.operator` is `"+"`, then return |AdditiveExpression| : _left_ <emu-t>+</emu-t> _right_.
          1. Else return |AdditiveExpression| : _left_ <emu-t>-</emu-t> _right_.
      1. Else, if _bin_`.operator` is `"|"`, `"/"`, or `"%"`, then:
          1. Let _left_ be MultiplicativeExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ExponentationExpressionEcmaify(_bin_`.right`).
          1. Let _op_ be an empty Parse Node.
          1. If _bin_`.operator` is `"|"`, then set _op_ to |MultiplicativeOperator| : __<tt>|</tt>__.
          1. Else, if _bin_`.operator` is `"/"`, then set _op_ to |MultiplicativeOperator| : <emu-t>/</emu-t>.
          1. Else, if _bin_`.operator` is `"%"`, then set _op_ to |MultiplicativeOperator| : <emu-t>%</emu-t>.
          1. Return |MultiplicativeExpression| : _left_ _op_ _right_.
      1. Else:
          1. Let _left_ be UpdateExpressionEcmaify(_bin_`.left`).
          1. Let _right_ be ExponentationExpressionEcmaify(_bin_`.right`).
          1. Return |ExponentiationExpression| : _left_ <emu-t>&#42;&#42;</emu-t> _right_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycallexpression" aoid="EcmaifyCallExpression">
    <h1>EcmaifyCallExpression ( _call_ )</h1>
    <emu-alg>
      1. Assert: _call_ is a `CallExpression`.
      1. Let _args_ be ArgumentsEcmaify(_call_`.arguments`).
      1. If _call_.callee is a `Super`, then:
          1. Let _superCall_ be |SuperCall| : <emu-t>super</emu-t> _args_.
          1. Return |CallExpression| : _superCall_.
      1. Else:
          1. NOTE: CallExpressions are canonicalized to have the callee to always be parenthesized.
          1. Let _callee_ be MemberExpressionEcmaify(_call_`.callee`).
          1. Return |CallExpression| : _callee_ _args_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecamifycompoundassignmentexpression" aoid="EcmaifyCompoundAssignmentExpression">
    <h1>EcmaifyCompoundAssignmentExpression ( _assign_ )</h1>
    <emu-alg>
      1. Assert: _assign_ is a `CompoundAssignmentExpression`.
      1. Let _lhs_ be LeftHandSideExpressionEcmaify(_assign_`.binding`)
      1. Let _rhs_ be AssignmentExpressionEcmaify(_assign_`.expression`).
      1. Let _op_ be an empty Parse Node.
      1. If _assign_`.operator` is `"|="` then set _op_ to |AssignmentOperator| : <emu-t>&#42;=</emu-t>.
      1. Else, if _assign_`.operator` is `"/="` then set _op_ to |AssignmentOperator| : <emu-t>/=</emu-t>.
      1. Else, if _assign_`.operator` is `"%="` then set _op_ to |AssignmentOperator| : <emu-t>%=</emu-t>.
      1. Else, if _assign_`.operator` is `"+="` then set _op_ to |AssignmentOperator| : <emu-t>+=</emu-t>.
      1. Else, if _assign_`.operator` is `"-="` then set _op_ to |AssignmentOperator| : <emu-t>-=</emu-t>.
      1. Else, if _assign_`.operator` is `"<<="` then set _op_ to |AssignmentOperator| : <emu-t><<=</emu-t>.
      1. Else, if _assign_`.operator` is `">>="` then set _op_ to |AssignmentOperator| : <emu-t>>>=</emu-t>.
      1. Else, if _assign_`.operator` is `">>>="` then set _op_ to |AssignmentOperator| : <emu-t>>>>=</emu-t>.
      1. Else, if _assign_`.operator` is `"&="` then set _op_ to |AssignmentOperator| : <emu-t>&=</emu-t>.
      1. Else, if _assign_`.operator` is `"^="` then set _op_ to |AssignmentOperator| : <emu-t>^=</emu-t>.
      1. Else, if _assign_`.operator` is `"|="` then set _op_ to |AssignmentOperator| : <emu-t>|=</emu-t>.
      1. Else, set _op_ to |AssignmentOperator| : <emu-t>&#42;&#42;=</emu-t>.
      1. Return |AssignmentExpression| : _lhs_ _op_ _rhs_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycomputedmemberexpression" aoid="EcmaifyComputedMemberExpression">
    <h1>EcmaifyComputedMemberExpression ( _getelem_ )</h1>
    <emu-alg>
      1. Assert: _getelem_ is a `ComputedMemberExpression`.
      1. Let _expr_ be ExpressionEcmaify(_getelem_`.expression`).
      1. If _getelem_`._object` is a `Super`, then:
          1. Let _superProp_ be |SuperProperty| : <emu-t>super</emu-t> <emu-t>[</emu-t> _expr_ <emu-t>]</emu-t>.
          1. Return |MemberExpression| : _superProp_.
      1. Else:
          1. Let _base_ be MemberExpressionEcmaify(_getelem_`._object`).
          1. Return |MemberExpression| : _base_ <emu-t>[</emu-t> _expr_ <emu-t>]</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyconditionalexpression" aoid="EcmaifyConditionalExpression">
    <h1>EcmaifyConditionalExpression ( _hook_ )</h1>
    <emu-alg>
      1. Assert: _hook_ is a `ConditionalExpression`.
      1. Let _test_ be LogicalORExpressionEcmaify(_hook_`.test`).
      1. Let _then_ be AssignmentExpressionEcmaify(_hook_`.consequent`).
      1. Let _else_ be AssignmentExpressionEcmaify(_hook_`.alternate`).
      1. Return |ConditionalExpression| : _test_ <emu-t>?</emu-t> _then_ <emu-t>:</emu-t> _else_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyclassexpression" aoid="EcmaifyClassExpression">
    <h1>EcmaifyClassExpression ( _cls_ )</h1>
    <emu-alg>
      1. Assert: _cls_ is a `ClassExpression`.
      1. TODO.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyfunctionexpression" aoid="EcmaifyFunctionExpression">
    <h1>EcmaifyFunctionExpression ( _func_ )</h1>
    <emu-alg>
      1. Assert: _func_ is a `FunctionExpression`.
      1. Let _params_ be Ecmaify(_func_`.params`).
      1. If _func_`.isAsync` is *true*, then:
          1. Let _body_ be |AsyncFunctionBody| : LazyFunctionBodyEcmaify(_func_`.body`).
          1. Return |AsyncFunctionExpression| : <emu-t>async</emu-t> <emu-t>function</emu-t> _func_`.name` <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else, if _func_`.isGenerator` is *true*, then:
          1. Let _body_ be |GeneratorBody| : LazyFunctionBodyEcmaify(_func_`.body`).
          1. Return |GeneratorExpression| : <emu-t>function</emu-t> <emu-t>*</emu-t> _func_`.name` <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
      1. Else:
          1. Let _body_ be LazyFunctionBodyEcmaify(_func_`.body`).
          1. Return |FunctionExpression| : <emu-t>function</emu-t> _func_`.name` <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyidentifierexpression" aoid="EcmaifyIdentifierExpression">
    <h1>EcmaifyIdentifierExpression ( _ident_ )</h1>
    <emu-alg>
      1. Assert: _ident_ is an `IdentifierExpression`.
      1. If _ident_`.name` is the empty string, throw a *SyntaxError* exception.
      1. If _ident_`.name` is "yield", then return |IdentifierReference| : <emu-t>yield</emu-t>.
      1. If _ident_`.name` is "await", then return |IdentifierReference| : <emu-t>await</emu-t>.
      1. Else:
          1. Let _name_ be |Identifier| : _ident_`.name`.
          1. Return |IdentifierReference| : _name_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifynewexpression" aoid="EcmaifyNewExpression">
    <h1>EcmaifyNewExpression ( _new_ )</h1>
    <emu-alg>
      1. NOTE: New expressions are canonicalized to the arguments-taking verison.
      1. Assert: _new_ is a `NewExpression`.
      1. Let _callee_ be MemberExpressionEcmaify(_new_`.callee`).
      1. Let _args_ be ArgumentesEcmaify(_new_`.arguments`).
      1. Return |MemberExpression|: <emu-t>new</emu-t> _callee_ _args_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifynewtargetexpression" aoid="EcmaifyNewTargetExpression">
    <h1>EcmaifyNewTargetExpression ( _newTarget_ )</h1>
    <emu-alg>
      1. Assert: _newTarget_ is a `NewTargetExpression`.
      1. Let _n_ be |NewTarget| : <emu-t>new</emu-t> <emu-t>.</emu-t> <emu-t>target</emu-t>.
      1. Return |MetaProperty| : _n_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyobjectexpression" aoid="EcmaifyObjectExpression">
    <h1>EcmaifyObjectExpression ( _litObj_ )</h1>
    <emu-alg>
      1. Assert: _litObj_ is an `ObjectExpression`.
      1. If _litObj_`.properties` has length 0, then return |ObjectLiteral| : <emu-t>{</emu-t> <emu-t>}</emu-t>.
      1. Else:
          1. Let _props_ be PropertyDefinitionListEcmaify(_litObj_`.properties`).
          1. Return |ObjectLiteral| : <emu-t>{</emu-t> _props_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyunaryexpression" aoid="EcmaifyUnaryExpression">
    <h1>EcmaifyUnaryExpression ( _unary_ )</h1>
    <emu-alg>
      1. Assert: _unary_ is an `UnaryExpression`.
      1. Let _operand_ be UnaryExpressionEcmaify(_unary_`.operand`).
      1. If _unary_`.operator` is "delete", then return |UnaryExpression| : <emu-t>delete</emu-t> _operand_.
      1. Else, if _unary_`.operator` is "void", then return |UnaryExpression| : <emu-t>void</emu-t> _operand_.
      1. Else, if _unary_`.operator` is "typeof", then return |UnaryExpression| : <emu-t>typeof</emu-t> _operand_.
      1. Else, if _unary_`.operator` is "+", then return |UnaryExpression| : <emu-t>+</emu-t> _operand_.
      1. Else, if _unary_`.operator` is "-", then return |UnaryExpression| : <emu-t>-</emu-t> _operand_.
      1. Else, if _unary_`.operator` is "~", then return |UnaryExpression| : <emu-t>~</emu-t> _operand_.
      1. Else, return |UnaryExpression| : <emu-t>!</emu-t> _operand_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifystaticmemberexpression" aoid="EcmaifyStaticMemberExpression">
    <h1>EcmaifyStaticMemberExpression ( _getprop_ )</h1>
    <emu-alg>
      1. Assert: _getprop_ is a `StaticMemberExpression`.
      1. If _getprop_`._object` is a `Super`, then:
          1. Let _superProp_ be |SuperProperty| : <emu-t>super</emu-t> <emu-t>.</emu-t> _getprop_`.property`.
          1. Return |MemberExpression| : _superProp_.
      1. Else:
          1. Let _base_ be MemberExpressionEcmaify(_getprop_`._object`).
          1. Return |MemberExpression| : _base_ <emu-t>.</emu-t> _getprop_`.property`.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifytemplateexpression" aoid="EcmaifyTemplateExpression">
    <h1>EcmaifyTemplateExpression ( _litTemplate_ )</h1>
    <emu-alg>
      1. Assert: _litTemplate_ is a `TemplateExpression`.
      1. TODO.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifythisexpression" aoid="EcmaifyThisExpression">
    <h1>EcmaifyThisExpression ( _this_ )</h1>
    <emu-alg>
      1. Assert: _this_ is a `ThisExpression`.
      1. Return |PrimaryExpression| : <emu-t>this</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyupdateexpression" aoid="EcmaifyUpdateExpression">
    <h1>EcmaifyUpdateExpression ( _upd_ )</h1>
    <emu-alg>
      1. Assert: _upd_ is an `UpdateExpression`.
      1. If _upd_`.isPrefix` is *true*, then:
          1. Let _operand_ be UnaryExpressionEcmaify(_upd_`.operand`).
          1. If _upd_`.operator` is "++", then return |UpdateExpression| : <emu-t>++</emu-t> _operand_.
          1. Else, return |UpdateExpression| : <emu-t>--</emu-t> _operand_.
      1. Else:
          1. Let _operand_ be LeftHandSideExpressionEcmaify(_upd_`.operand`).
          1. If _upd_`.operator` is "++", then return |UpdateExpression| : _operand_ <emu-t>++</emu-t>.
          1. Else, return |UpdateExpression| : _operand_ <emu-t>--</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyyieldexpression" aoid="EcmaifyYieldExpression">
    <h1>EcmaifyYieldExpression ( _yield_ )</h1>
    <emu-alg>
      1. Assert: _yield_ is a `YieldExpression`.
      1. If _yield_`.expression` is null, then:
          1. Return |YieldExpression| : <emu-t>yield</emu-t>.
      1. Else:
          1. Let _expr_ be AssignmentExpressionEcmaify(_yield_`.expression`).
          1. Return |YieldExpression| : <emu-t>yield</emu-t> _expr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyyieldstarexpression" aoid="EcmaifyYieldStarExpression">
    <h1>EcmaifyYieldStarExpression ( _yieldStart_ )</h1>
    <emu-alg>
      1. Assert: _yieldStar_ is a `YieldStarExpression`.
      1. Let _expr_ be AssignmentExpressionEcmaify(_yieldStar_`.expression`).
      1. Return |YieldExpression| : <emu-t>yield</emu-t> <emu-t>&ast;</emu-t> _expr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyawaitexpression" aoid="EcmaifyAwaitExpression">
    <h1>EcmaifyAwaitExpression ( _await_ )</h1>
    <emu-alg>
      1. Assert: _await_ is an `AwaitExpression`.
      1. Let _expr_ be UnaryExpressionEcmaify(_await_`.expression`).
      1. Return |AwaitExpression| : <emu-t>await</emu-t> _expr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyformalparameters" aoid="EcmaifyFormalParameters">
    <h1>EcmaifyFormalParameters ( _params_ )</h1>
    <emu-alg>
      1. Assert: _params_ is a `FormalParameters`.
      1. If _params_`.items` has length 0, then:
          1. If _params_`.rest` is null, then return |FormalParameters| :.
          1. Else:
              1. Let _rest_ be |FunctionRestParameter| : Ecmaify(_params_`.rest`).
              1. Return |FormalParameters| : _rest_.
      1. Else:
          1. Let _list_ be FormalParameterListEcmaify(_params_`.items`).
          1. If _params_`.rest` is null, then return |FormalParameters| : _list_.
          1. Else:
              1. Let _rest_ be |FunctionRestParameter| : Ecmaify(_params_`.rest`).
              1. Return |FormalParameters| : _list_ <emu-t>,</emu-t> _rest_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifymethod" aoid="EcmaifyMethod">
    <h1>EcmaifyMethod ( _method_ )</h1>
    <emu-alg>
      1. Assert: _method_ is a `Method`.
      1. Let _name_ be |PropertyName| : Ecmaify(_method_`.name`).
      1. Let _params0_ be Ecmaify(_method_`.params`).
      1. If _method_`.isAsync` is |true|, then:
          1. Let _params_ be |UniqueFormalParameters| : _params0_.
          1. Let _body_ be |AsyncFunctionBody| : LazyFunctionBodyEcmaify(_method_`.body`).
          1. Let _m_ be |AsyncMethod| : <emu-t>async</emu-t> _name_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
          1. Return |MethodDefinition| : _m_.
      1. Else, if _method_`.isGenerator` is |true|, then:
          1. Let _params_ be |UniqueFormalParameters| : _params0_.
          1. Let _body_ be |GeneratorBody| : LazyFunctionBodyEcmaify(_method_`.body`).
          1. Let _m_ |GeneratorMethod| : <emu-t>*</emu-t> _name_ <emu-t>(</emu-t> _params_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
          1. Return |MethodDefinition| : _m_.
      1. Else:
          1. Let _body_ be LazyFunctionBodyEcmaify(_method_`.body`).
          1. Return |MethodDefinition| : _name_ <emu-t>(</emu-t> _params0_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifygetter" aoid="EcmaifyGetter">
    <h1>EcmaifyGetter ( _getter_ )</h1>
    <emu-alg>
      1. Assert: _getter_ is a `Getter`.
      1. Let _name_ be |PropertyName| : Ecmaify(_getter_`.name`).
      1. Let _body_ be LazyFunctionBodyEcmaify(_getter_`.body`).
      1. Return |MethodDefinition| : <emu-t>get</emu-t> _name_ <emu-t>(</emu-t> <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifysetter" aoid="EcmaifySetter">
    <h1>EcmaifySetter ( _setter_ )</h1>
    <emu-alg>
      1. Assert: _setter_ is a `Setter`.
      1. Let _name_ be |PropertyName| : Ecmaify(_setter_`.name`).
      1. Let _param_ be |PropertySetParameterList| : Ecmaify(_setter_`.param`).
      1. Let _body_ be LazyFunctionBodyEcmaify(_setter_`.body`).
      1. Return |MethodDefinition| : <emu-t>set</emu-t> _name_ <emu-t>(</emu-t> _param_ <emu-t>)</emu-t> <emu-t>{</emu-t> _body_ <emu-t>}</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifydataproperty" aoid="EcmaifyDataProperty">
    <h1>EcmaifyDataProperty ( _prop_ )</h1>
    <emu-alg>
      1. Assert: _prop_ is a `DataProperty`.
      1. Let _name_ be |PropertyName| : Ecmaify(_prop_`.name`).
      1. Let _expr_ be AssignmentExpressionEcmaify(_prop_`.expression`).
      1. Return |PropertyDefinition| : _name_ <emu-t>:</emu-t> _expr_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyshorthandproperty" aoid="EcmaifyShorthandProperty">
    <h1>EcmaifyShorthandProperty ( _prop_ )</h1>
    <emu-alg>
      1. Assert: _prop_ is a `ShorthandProperty`.
      1. Let _ident_ be Ecmaify(_prop_`.name`).
      1. Return |PropertyDefinition| : _ident_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycomputedpropertyname" aoid="EcmaifyComputedPropertyName">
    <h1>EcmaifyComputedPropertyName ( _name_ )</h1>
    <emu-alg>
      1. Assert: _name_ is a `ComputedPropertyName`.
      1. Let _expr_ be AssignmentExpressionEcmaify(_name_`.expression`).
      1. Return |ComputedPropertyName| : <emu-t>[</emu-t> _expr_ <emu-t>]</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyliteralpropertyname" aoid="EcmaifyLiteralPropertyName">
    <h1>EcmaifyLiteralPropertyName ( _name_ )</h1>
    <emu-alg>
      1. NOTE: Literal property names are canonicalized to double quoted string literals.
      1. Assert: _name_ is a `LiteralPropertyName`.
      1. Let _v_ be the value of _name_`.value` escaped for double quotes.
      1. Let _l_ be |StringLiteral| : <emu-t>&#34;</emu-t> _v_ <emu-t>&#34;</emu-t>.
      1. Return |LiteralPropertyName| : _l_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyparameter" aoid="EcmaifyParameter">
    <h1>EcmaifyParameter ( _param_ )</h1>
    <emu-alg>
      1. Assert: _param_ is a `Parameter`.
      1. Return |FormalParameter| : Ecmaify(_param_).
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyvariabledeclarationkind" aoid="EcmaifyVariableDeclarationKind">
    <h1>EcmaifyVariableDeclarationKind ( _k_ )</h1>
    <emu-alg>
      1. Assert: _k_ is `"let"` or `"const"`.
      1. If _k_ is `"let"`, then return |LetOrConst| : <emu-t>let</emu-t>.
      1. Else, return |LetOrConst| : <emu-t>const</emu-t>.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifyforinofbinding" aoid="EcmaifyForInOfBinding">
    <h1>EcmaifyForInOfBinding ( _b_ )</h1>
    <emu-alg>
      1. Assert: _b_ is a `ForInOfBinding`.
      1. Let _binding_ be |ForBinding| : Ecmaify(_b_`.binding`).
      1. If _b_.kind is `"var"`, then:
          1. Return the partial Parse Node <emu-t>var</emu-t> _binding_.
      1. Else, return |ForDeclaration| : Ecmaify(_b_`.kind`) _binding_.
    </emu-alg>
  </emu-clause>

  <emu-clause id="sec-ecmaifycatchclause" aoid="EcmaifyCatchClause">
    <h1>EcmaifyCatchClause ( _catchClause_ )</h1>
    <emu-alg>
      1. Assert: _catchClause_ is a `CatchClause`.
      1. Let _binding_ be Ecmaify(_catchClause_`.binding`).
      1. Let _body_ be Ecmaify(_catchClause_`.body`).
      1. Return |Catch| : <emu-t>catch</emu-t> <emu-t>(</emu-t> _binding_ <emu-t>)</emu-t> _body_.
    </emu-alg>
  </emu-clause>

</emu-clause>
